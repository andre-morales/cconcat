from pathlib import Path
from typing import List
import argparse as ArgParse

TERM_YELLOW = "\033[33m"
TERM_CLEAR = "\033[0m"

includedFiles: List[Path] = []
baseDirPath: Path = None
cliArgs = None

def main():
	global baseDirPath, cliArgs

	# Parse CLI options
	parser = ArgParse.ArgumentParser()
	parser.add_argument('entry')
	parser.add_argument('-o', '--output', required=False, default="result.c")
	parser.add_argument('-v', '--verbose', action='store_true')
	parser.add_argument('-eh', '--emit_header', action='store_true')
	cliArgs = parser.parse_args()

	# Create entry path
	baseDirPath = Path('.').resolve()
	entryPath = Path(cliArgs.entry)

	resultLines = []

	# Add header if requested so
	if cliArgs.emit_header:
		resultLines.append("// ## --- Generated by CConcat v0.2 --- ##\n")
		resultLines.append("// ## ---       AndrÃ© Morales       --- ##\n")
	
	# Resolve the entry C file
	entryLines = getResolvedContent(entryPath, 0)
	resultLines.extend(entryLines)

	# Try to find the source file for each header file
	for headerFile in includedFiles:
		if not headerFile.name.endswith('.h'): continue

		# Try to find the corresponding source file in the same directory as the header file
		sourceFile = headerFile.parent.joinpath(headerFile.name.removesuffix('.h') + '.c')
		if not sourceFile.exists():
			vprint(f"Source file for {headerFile} does not exist.")
			continue

		# Resolve the .c source file as well
		sourceContent = getResolvedContent(sourceFile, 0)
		resultLines.extend(sourceContent)

	# Write the final result
	with open(cliArgs.output, "w") as result:
		result.writelines(resultLines)

	vprint("ccat finished successfully.")
	return

def getResolvedContent(sourcePath: Path, depth: int, forget=False) -> List[str]:
	global baseDirPath

	sourcePath = sourcePath.resolve().relative_to(baseDirPath, walk_up=True)
	vprint('|   ' * depth + f"Resolving {TERM_YELLOW}'{sourcePath}'{TERM_CLEAR}", end='')
	
	# Do not add any lines if this file has been included before
	if (sourcePath in includedFiles):
		vprint(' Skipped.')
		return []
	else:
		vprint(' Done.')

	# Add this file to the list of included files
	if not forget:
		includedFiles.append(sourcePath)

	# Open the file
	try:
		with open(sourcePath, "r") as file:
			lines = file.readlines()
	except:
		raise Exception(f"ERR: Unable to resolve '{sourcePath}'")

	# File inclusion preamble
	emittedLines = []
	emittedLines.append('\n')
	emittedLines.append(f'// --- {depth} FILE: {sourcePath} ---')
	emittedLines.append('\n')

	for l in lines:
		# Remove #pragma once directives
		if l.strip() == '#pragma once':
			continue

		pathStr = getIncludePath(l)
		if pathStr == None:
			emittedLines.append(l)
		else:
			path = sourcePath.parent.joinpath(pathStr)
			includedLines = getResolvedContent(path, depth + 1)
			emittedLines.extend(includedLines)

	return emittedLines

def getIncludePath(line: str) -> str:
	sline = line.strip()

	# Ignore any non include lines
	if not sline.startswith("#include "):
		return None
	
	# Ignore includes that use angle brackets <>
	quotedPath = sline.removeprefix("#include ").strip()
	if not (quotedPath.startswith('"') or quotedPath.endswith('"')):
		return None
	
	# Get the actual path string
	path = quotedPath.removeprefix('"').removesuffix('"')
	return path

def vprint(*args, end='\n'):
	if cliArgs.verbose:
		print(*args, end=end)


if __name__ == '__main__':
	main()